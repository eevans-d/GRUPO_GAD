# -*- coding: utf-8 -*-
"""
Manejador mejorado para mensajes de texto con control de atajos.

Quick Win #4: Control de atajos
- Deshabilita comandos texto libre durante wizard/confirmaciones
- Estados sensibles para prevenir acciones involuntarias
- Validaci√≥n de entrada seg√∫n contexto
"""

import re
from telegram import Update
from telegram.ext import CallbackContext, MessageHandler, filters
from telegram import Bot, Chat, User
from loguru import logger

from config.settings import settings
from src.bot.services.api_service import ApiService
from src.bot.utils.wizard_state import (
    wizard_manager, can_process_text_input, is_wizard_active, WizardState
)
from src.bot.utils.validators import TaskValidator, UnifiedCopy
from src.bot.utils.error_messages import ErrorMessages, log_error, ErrorCategory
from src.bot.utils.ux_metrics import ux_metrics
from src.bot.utils.emojis import StatusEmojis, ActionEmojis
from src.bot.handlers.wizard_text_handler import get_step_header


async def message_handler_improved(
    update: Update, 
    context: CallbackContext[Bot, Update, Chat, User]
) -> None:
    """
    Procesa mensajes de texto con control de estado del wizard.
    
    Quick Win #4: Deshabilita atajos durante wizard/confirmaciones.
    
    Args:
        update: Update de Telegram
        context: Contexto de la conversaci√≥n
    """
    if not update.message or not update.message.from_user or not update.message.text:
        return
    
    user_id = update.message.from_user.id
    msg_text = update.message.text.strip()
    
    # Quick Win #4: Verificar si hay wizard activo
    if is_wizard_active(user_id):
        await _handle_wizard_text_input(update, context, user_id, msg_text)
        return
    
    # Quick Win #4: Fuera del wizard, procesar atajos normales
    # Buscar patr√≥n "listo + c√≥digo"
    match = re.match(r"^(?i)listo\s+(\S+)", msg_text)
    if match:
        codigo_tarea = match.group(1)
        await _handle_listo_shortcut(update, context, user_id, codigo_tarea)
        return
    
    # Si no es un atajo conocido y no hay wizard, informar
    await update.message.reply_text(
        f"{StatusEmojis.INFO} *Mensaje no reconocido*\n\n"
        f"Para usar el bot, usa:\n"
        f"‚Ä¢ /start - Men√∫ principal\n"
        f"‚Ä¢ /ayuda - Ver ayuda completa\n\n"
        f"üí° *Atajos disponibles:*\n"
        f"‚Ä¢ `listo C√ìDIGO` - Finalizar tarea\n"
        f"  Ejemplo: `listo OPE-2025-001`",
        parse_mode="Markdown"
    )


async def _handle_wizard_text_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    user_id: int,
    msg_text: str
) -> None:
    """
    Maneja entrada de texto durante wizard activo.
    
    Quick Win #3: Validaciones con copy unificado
    Quick Win #4: Control de entrada seg√∫n estado
    Quick Win #5: Tracking de errores de validaci√≥n
    
    Args:
        update: Update de Telegram
        context: Contexto
        user_id: ID de usuario
        msg_text: Texto ingresado
    """
    session = wizard_manager.get_session(user_id)
    state = session.state
    
    # Quick Win #4: Verificar si se permite entrada de texto
    if not can_process_text_input(user_id):
        # Estado no permite texto libre
        await update.message.reply_text(
            f"{StatusEmojis.WARNING} *Entrada no permitida en este momento*\n\n"
            f"Por favor usa los botones para continuar.\n\n"
            f"üí° Si necesitas cancelar, usa: /cancelar",
            parse_mode="Markdown"
        )
        return
    
    # Procesar seg√∫n el paso del wizard
    if state == WizardState.ENTERING_CODE:
        await _process_codigo_input(update, context, user_id, msg_text)
    
    elif state == WizardState.ENTERING_TITLE:
        await _process_titulo_input(update, context, user_id, msg_text)
    
    elif state == WizardState.SELECTING_DELEGADO:
        await _process_delegado_input(update, context, user_id, msg_text)
    
    elif state == WizardState.SELECTING_ASIGNADOS:
        await _process_asignados_input(update, context, user_id, msg_text)
    
    else:
        # Estado inesperado
        await update.message.reply_text(
            f"{StatusEmojis.WARNING} *Estado inesperado del wizard*\n\n"
            f"Por favor usa /cancelar para reiniciar o /start para volver al men√∫.",
            parse_mode="Markdown"
        )


async def _process_codigo_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    user_id: int,
    codigo: str
) -> None:
    """
    Procesa entrada de c√≥digo con validaci√≥n.
    
    Quick Win #3: Validaci√≥n de c√≥digo con l√≠mite de 20 caracteres
    """
    # Quick Win #3: Validar c√≥digo
    validation = TaskValidator.validate_codigo(codigo)
    
    if not validation.is_valid:
        # Quick Win #2: Mensaje de error espec√≠fico
        error_msg = ErrorMessages.format_validation_error(
            field=validation.field_name or "C√≥digo",
            value=codigo,
            issue=validation.error_message or "C√≥digo inv√°lido",
            suggestion=validation.suggestion or "",
            max_length=UnifiedCopy.MAX_CODIGO_LENGTH
        )
        
        await update.message.reply_text(
            error_msg,
            parse_mode="Markdown"
        )
        
        # Quick Win #5: Track error de validaci√≥n
        ux_metrics.track_validation_error(
            user_id=user_id,
            field="codigo",
            error_type="format_error",
            step=2
        )
        
        log_error(
            ErrorCategory.VALIDATION,
            f"C√≥digo inv√°lido: {codigo}",
            user_id=user_id
        )
        return
    
    # C√≥digo v√°lido - guardar y avanzar
    if 'wizard' not in context.user_data:
        context.user_data['wizard'] = {'command': 'crear', 'data': {}}
    
    context.user_data['wizard']['data']['codigo'] = codigo
    context.user_data['wizard']['current_step'] = 3
    
    # Quick Win #4: Actualizar estado
    wizard_manager.advance_state(
        user_id,
        WizardState.ENTERING_TITLE,
        data={'codigo': codigo}
    )
    
    # Quick Win #5: Completar paso 2, iniciar paso 3
    ux_metrics.track_step_complete(user_id, 2)
    ux_metrics.track_step_start(user_id, 3)
    
    logger.bind(wizard=True).info(
        f"C√≥digo ingresado: {codigo}",
        user_id=user_id
    )
    
    # Solicitar t√≠tulo
    header = get_step_header(3, "Crear Nueva Tarea")
    
    await update.message.reply_text(
        f"{header}\n"
        f"‚úÖ C√≥digo: `{codigo}`\n\n"
        f"‚úèÔ∏è *Ingresa el t√≠tulo descriptivo de la tarea:*\n\n"
        f"üìù *Consejos para un buen t√≠tulo:*\n"
        f"‚Ä¢ S√© espec√≠fico y claro\n"
        f"‚Ä¢ Menciona la ubicaci√≥n si aplica\n"
        f"‚Ä¢ M√°ximo {UnifiedCopy.MAX_TITULO_LENGTH} caracteres\n"
        f"‚Ä¢ M√≠nimo {UnifiedCopy.MIN_TITULO_LENGTH} caracteres\n\n"
        f"üí¨ *Ejemplo:* \"Reparar tuber√≠a principal edificio A\"\n\n"
        f"üìä Caracteres disponibles: {UnifiedCopy.MAX_TITULO_LENGTH}\n\n"
        f"{ActionEmojis.CANCEL} Cancelar: /cancelar",
        parse_mode="Markdown"
    )


async def _process_titulo_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    user_id: int,
    titulo: str
) -> None:
    """
    Procesa entrada de t√≠tulo con validaci√≥n.
    
    Quick Win #3: L√≠mite consistente de 100 caracteres
    """
    # Quick Win #3: Validar t√≠tulo
    validation = TaskValidator.validate_titulo(titulo)
    
    if not validation.is_valid:
        # Quick Win #2: Mensaje de error espec√≠fico
        error_msg = ErrorMessages.format_validation_error(
            field=validation.field_name or "T√≠tulo",
            value=titulo,
            issue=validation.error_message or "T√≠tulo inv√°lido",
            suggestion=validation.suggestion or "",
            max_length=UnifiedCopy.MAX_TITULO_LENGTH
        )
        
        await update.message.reply_text(
            error_msg,
            parse_mode="Markdown"
        )
        
        # Quick Win #5: Track error
        ux_metrics.track_validation_error(
            user_id=user_id,
            field="titulo",
            error_type="length_error",
            step=3
        )
        return
    
    # T√≠tulo v√°lido - guardar y avanzar
    context.user_data['wizard']['data']['titulo'] = titulo
    context.user_data['wizard']['current_step'] = 4
    
    wizard_manager.advance_state(
        user_id,
        WizardState.SELECTING_DELEGADO,
        data={'titulo': titulo}
    )
    
    ux_metrics.track_step_complete(user_id, 3)
    ux_metrics.track_step_start(user_id, 4)
    
    logger.bind(wizard=True).info(
        f"T√≠tulo ingresado: {titulo}",
        user_id=user_id
    )
    
    # Quick Win #3: Solicitar delegado con terminolog√≠a unificada
    header = get_step_header(4, "Crear Nueva Tarea")
    
    await update.message.reply_text(
        f"{header}\n"
        f"‚úÖ T√≠tulo: {titulo}\n\n"
        f"üë§ *Selecciona el {UnifiedCopy.DELEGADO_TERM}:*\n\n"
        f"{StatusEmojis.INFO} *{UnifiedCopy.HELP_DELEGADO}*\n\n"
        f"üìù *Instrucci√≥n:*\n"
        f"Env√≠a el ID del {UnifiedCopy.DELEGADO_TERM.lower()}\n"
        f"Ejemplo: `101`\n\n"
        f"{ActionEmojis.CANCEL} Cancelar: /cancelar",
        parse_mode="Markdown"
    )


async def _process_delegado_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    user_id: int,
    delegado_id_str: str
) -> None:
    """
    Procesa ID de delegado con validaci√≥n.
    """
    validation = TaskValidator.validate_user_id(delegado_id_str)
    
    if not validation.is_valid:
        error_msg = ErrorMessages.format_validation_error(
            field=UnifiedCopy.DELEGADO_TERM,
            value=delegado_id_str,
            issue=validation.error_message or "ID inv√°lido",
            suggestion=validation.suggestion or ""
        )
        
        await update.message.reply_text(
            error_msg,
            parse_mode="Markdown"
        )
        
        ux_metrics.track_validation_error(
            user_id=user_id,
            field="delegado_id",
            error_type="format_error",
            step=4
        )
        return
    
    delegado_id = int(delegado_id_str)
    
    context.user_data['wizard']['data']['delegado_id'] = delegado_id
    context.user_data['wizard']['current_step'] = 5
    
    wizard_manager.advance_state(
        user_id,
        WizardState.SELECTING_ASIGNADOS,
        data={'delegado_id': delegado_id}
    )
    
    ux_metrics.track_step_complete(user_id, 4)
    ux_metrics.track_step_start(user_id, 5)
    
    # Solicitar asignados
    header = get_step_header(5, "Crear Nueva Tarea")
    
    await update.message.reply_text(
        f"{header}\n"
        f"‚úÖ {UnifiedCopy.DELEGADO_TERM}: ID {delegado_id}\n\n"
        f"üë• *Selecciona los {UnifiedCopy.ASIGNADOS_TERM}:*\n\n"
        f"{StatusEmojis.INFO} *{UnifiedCopy.HELP_ASIGNADOS}*\n\n"
        f"üìù *Instrucci√≥n:*\n"
        f"Env√≠a IDs separados por comas o deja vac√≠o\n"
        f"Ejemplos:\n"
        f"‚Ä¢ `201, 202, 203`\n"
        f"‚Ä¢ `/continuar` (sin asignados)\n\n"
        f"{ActionEmojis.CANCEL} Cancelar: /cancelar",
        parse_mode="Markdown"
    )


async def _process_asignados_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    user_id: int,
    asignados_str: str
) -> None:
    """
    Procesa lista de IDs de asignados.
    """
    validation, asignados_ids = TaskValidator.validate_user_ids_list(asignados_str)
    
    if not validation.is_valid:
        error_msg = ErrorMessages.format_validation_error(
            field=UnifiedCopy.ASIGNADOS_TERM,
            value=asignados_str,
            issue=validation.error_message or "IDs inv√°lidos",
            suggestion=validation.suggestion or ""
        )
        
        await update.message.reply_text(
            error_msg,
            parse_mode="Markdown"
        )
        
        ux_metrics.track_validation_error(
            user_id=user_id,
            field="asignados",
            error_type="format_error",
            step=5
        )
        return
    
    context.user_data['wizard']['data']['asignados'] = asignados_ids
    context.user_data['wizard']['current_step'] = 6
    
    wizard_manager.advance_state(
        user_id,
        WizardState.CONFIRMING,
        data={'asignados': asignados_ids}
    )
    
    ux_metrics.track_step_complete(user_id, 5)
    ux_metrics.track_step_start(user_id, 6)
    
    # Quick Win #1: Mostrar confirmaci√≥n con previsualizaci√≥n
    from src.bot.utils.confirmations import ConfirmationFormatter, ConfirmationPattern
    
    task_data = context.user_data['wizard']['data']
    confirmation_msg = ConfirmationFormatter.format_task_confirmation(task_data)
    keyboard = ConfirmationPattern.standard_confirmation("crear")
    
    await update.message.reply_text(
        confirmation_msg,
        reply_markup=keyboard,
        parse_mode="Markdown"
    )


async def _handle_listo_shortcut(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    user_id: int,
    codigo_tarea: str
) -> None:
    """
    Maneja atajo "listo + c√≥digo" para finalizar tarea.
    
    Quick Win #4: Solo funciona si NO hay wizard activo.
    """
    try:
        api_service = ApiService(settings.API_V1_STR)
        api_service.finalize_task(
            task_code=codigo_tarea,
            telegram_id=user_id
        )
        
        await update.message.reply_text(
            f"{StatusEmojis.SUCCESS} *¬°Tarea Finalizada!*\n\n"
            f"Tarea `{codigo_tarea}` finalizada exitosamente.\n\n"
            f"üí° Usa /start para volver al men√∫ principal",
            parse_mode="Markdown"
        )
        
        logger.bind(shortcut=True).info(
            f"Tarea finalizada v√≠a atajo: {codigo_tarea}",
            user_id=user_id
        )
        
    except Exception as e:
        error_msg = ErrorMessages.format_api_error(
            operation="finalizar la tarea",
            error_code="API_ERROR",
            technical_details=str(e)[:100]
        )
        
        await update.message.reply_text(
            error_msg,
            parse_mode="Markdown"
        )
        
        log_error(
            ErrorCategory.API_ERROR,
            f"Error en atajo listo: {str(e)}",
            user_id=user_id,
            context={'codigo': codigo_tarea}
        )


# Exportar handler configurado
handler_improved = MessageHandler(
    filters.TEXT & ~filters.COMMAND,
    message_handler_improved
)
