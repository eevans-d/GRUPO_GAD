# -*- coding: utf-8 -*-
"""
Manejador de texto para wizard de creaci√≥n/finalizaci√≥n de tareas.
"""

from telegram import Update
from telegram.ext import CallbackContext, MessageHandler, filters
from telegram import Bot, Chat, User
from loguru import logger
from typing import Dict, Any

from src.bot.utils.keyboards import KeyboardFactory
from src.bot.utils.emojis import (
    TaskEmojis, StatusEmojis, ActionEmojis, ProgressEmojis,
    get_task_emoji
)


# ==================== UTILIDADES DE PROGRESS ====================

def get_progress_bar(step: int, total: int = 6) -> str:
    """
    Genera una barra de progreso visual para el wizard.
    
    Args:
        step: Paso actual (1-based)
        total: Total de pasos
    
    Returns:
        String con barra de progreso ASCII con emojis
    """
    filled = step
    empty = total - step
    percentage = int((step / total) * 100)
    
    bar = (ProgressEmojis.FILLED * filled) + (ProgressEmojis.EMPTY * empty)
    return f"{bar} {percentage}%"


def get_step_header(current_step: int, title: str = "Crear Nueva Tarea") -> str:
    """
    Genera header mejorado con progress y paso actual.
    
    Args:
        current_step: Paso actual (1-6)
        title: T√≠tulo del wizard
    
    Returns:
        String formateado con progress
    """
    progress = get_progress_bar(current_step)
    return f"üìã *{title}* [Paso {current_step}/6]\n{progress}\n"


def format_task_summary(task_data: Dict[str, Any]) -> str:
    """
    Formatea el resumen de una tarea con dise√±o visual mejorado.
    
    Args:
        task_data: Diccionario con datos de la tarea (tipo, codigo, titulo, etc.)
    
    Returns:
        String con resumen formateado en Markdown con emojis sem√°nticos
    """
    tipo = task_data.get('tipo', 'N/A')
    codigo = task_data.get('codigo', 'N/A')
    titulo = task_data.get('titulo', 'N/A')
    delegado_id = task_data.get('delegado_id', 'N/A')
    asignados = task_data.get('asignados', [])
    
    # Obtener emoji del tipo de tarea
    tipo_emoji = get_task_emoji(tipo)
    
    return (
        f"üìã *RESUMEN DE LA TAREA*\n"
        f"{'‚îÄ' * 30}\n\n"
        f"üî§ *C√≥digo:* `{codigo}`\n"
        f"üìù *T√≠tulo:* {titulo}\n"
        f"{tipo_emoji} *Tipo:* {tipo}\n"
        f"üë§ *Delegado:* ID `{delegado_id}`\n"
        f"üë• *Asignados:* {', '.join(map(str, asignados)) if asignados else 'Ninguno'}\n\n"
        f"{'‚îÄ' * 30}\n"
        f"‚ö†Ô∏è *¬øConfirmar creaci√≥n?*\n"
        f"Revisa los datos antes de continuar."
    )


def get_step_help(step: int) -> str:
    """
    Retorna texto de ayuda contextual para cada paso del wizard.
    
    Args:
        step: N√∫mero de paso del wizard (1-6)
    
    Returns:
        String con ayuda espec√≠fica para el paso
    """
    help_texts = {
        1: (
            f"{StatusEmojis.INFO} *Ayuda: Tipo de Tarea*\n\n"
            f"{TaskEmojis.OPERATIONAL} *OPERATIVO:* Tareas t√©cnicas y de campo\n"
            f"{TaskEmojis.ADMINISTRATIVE} *ADMINISTRATIVO:* Tareas de oficina y gesti√≥n\n"
            f"{TaskEmojis.EMERGENCY} *EMERGENCIA:* Situaciones urgentes que requieren atenci√≥n inmediata\n\n"
            f"Selecciona el tipo que mejor describe la tarea."
        ),
        2: (
            f"{StatusEmojis.INFO} *Ayuda: C√≥digo de Tarea*\n\n"
            f"üìå *Formato sugerido:* `TIPO-A√ëO-N√öMERO`\n"
            f"‚úÖ *Ejemplos v√°lidos:*\n"
            f"  ‚Ä¢ `OPE-2025-001`\n"
            f"  ‚Ä¢ `ADM-2025-042`\n"
            f"  ‚Ä¢ `EMG-2025-005`\n\n"
            f"‚ö†Ô∏è M√°ximo 20 caracteres\n"
            f"‚ö†Ô∏è Debe ser √∫nico en el sistema"
        ),
        3: (
            f"{StatusEmojis.INFO} *Ayuda: T√≠tulo de Tarea*\n\n"
            f"‚úçÔ∏è Escribe un t√≠tulo descriptivo y claro.\n\n"
            f"‚úÖ *Buenas pr√°cticas:*\n"
            f"  ‚Ä¢ S√© espec√≠fico y conciso\n"
            f"  ‚Ä¢ Incluye acci√≥n y objetivo\n"
            f"  ‚Ä¢ M√°ximo 100 caracteres\n\n"
            f"üìù *Ejemplos:*\n"
            f"  ‚Ä¢ 'Reparar tuber√≠a principal edificio A'\n"
            f"  ‚Ä¢ 'Actualizar inventario de equipos'\n"
            f"  ‚Ä¢ 'Responder emergencia en sector 3'"
        ),
        4: (
            f"{StatusEmojis.INFO} *Ayuda: Delegado*\n\n"
            f"üë§ Selecciona el usuario que *delegar√°* esta tarea.\n\n"
            f"üîë *Importante:*\n"
            f"  ‚Ä¢ El delegado es quien asigna la tarea\n"
            f"  ‚Ä¢ Tiene permisos de seguimiento\n"
            f"  ‚Ä¢ Puede modificar la tarea despu√©s\n\n"
            f"Selecciona un ID de la lista o escribe el ID del usuario."
        ),
        5: (
            f"{StatusEmojis.INFO} *Ayuda: Asignados*\n\n"
            f"üë• Selecciona los usuarios que *ejecutar√°n* esta tarea.\n\n"
            f"üìå *Puedes:*\n"
            f"  ‚Ä¢ Seleccionar m√∫ltiples usuarios\n"
            f"  ‚Ä¢ Dejar sin asignados (opcional)\n"
            f"  ‚Ä¢ Modificar selecci√≥n despu√©s\n\n"
            f"Env√≠a IDs separados por comas (ej: 101,102,103)"
        ),
        6: (
            f"{StatusEmojis.INFO} *Ayuda: Confirmaci√≥n*\n\n"
            f"‚úÖ Revisa cuidadosamente los datos antes de confirmar.\n\n"
            f"üí° *Opciones disponibles:*\n"
            f"  ‚Ä¢ {ActionEmojis.CONFIRM} *Confirmar:* Crear la tarea\n"
            f"  ‚Ä¢ {ActionEmojis.EDIT} *Editar:* Modificar datos\n"
            f"  ‚Ä¢ {ActionEmojis.CANCEL} *Cancelar:* Descartar todo\n\n"
            f"Una vez creada, podr√°s editarla desde el men√∫ principal."
        ),
    }
    
    return help_texts.get(step, f"{StatusEmojis.INFO} Ayuda no disponible para este paso.")


def validate_codigo(codigo: str) -> tuple[bool, str]:
    """
    Valida el c√≥digo de tarea en tiempo real.
    
    Args:
        codigo: C√≥digo ingresado por el usuario
    
    Returns:
        tuple: (es_valido, mensaje_feedback)
    """
    from src.bot.utils.emojis import ValidationEmojis
    
    # Validaci√≥n: no vac√≠o
    if not codigo or codigo.strip() == "":
        return (False, f"{ValidationEmojis.INVALID} El c√≥digo no puede estar vac√≠o.")
    
    # Validaci√≥n: longitud
    if len(codigo) > 20:
        return (False, f"{ValidationEmojis.INVALID} El c√≥digo es muy largo ({len(codigo)}/20 caracteres).")
    
    if len(codigo) < 3:
        return (False, f"{ValidationEmojis.INVALID} El c√≥digo es muy corto (m√≠nimo 3 caracteres).")
    
    # Validaci√≥n: formato sugerido
    if not any(c in codigo for c in ['-', '_', '.']):
        return (True, f"{ValidationEmojis.FORMAT_OK} Formato aceptable. Sugerencia: usa guiones (ej: OPE-2025-001)")
    
    return (True, f"{ValidationEmojis.VALID} C√≥digo v√°lido.")


def validate_titulo(titulo: str) -> tuple[bool, str]:
    """
    Valida el t√≠tulo de tarea en tiempo real.
    
    Args:
        titulo: T√≠tulo ingresado por el usuario
    
    Returns:
        tuple: (es_valido, mensaje_feedback)
    """
    from src.bot.utils.emojis import ValidationEmojis
    
    # Validaci√≥n: no vac√≠o
    if not titulo or titulo.strip() == "":
        return (False, f"{ValidationEmojis.INVALID} El t√≠tulo no puede estar vac√≠o.")
    
    # Validaci√≥n: longitud
    if len(titulo) > 100:
        return (False, f"{ValidationEmojis.INVALID} El t√≠tulo es muy largo ({len(titulo)}/100 caracteres).")
    
    if len(titulo) < 10:
        return (False, f"{ValidationEmojis.REQUIRED} El t√≠tulo es muy corto (m√≠nimo 10 caracteres para ser descriptivo).")
    
    # Validaci√≥n: contiene verbo de acci√≥n
    verbos_accion = [
        'reparar', 'actualizar', 'revisar', 'instalar', 'configurar', 
        'gestionar', 'coordinar', 'supervisar', 'verificar', 'completar',
        'realizar', 'ejecutar', 'implementar', 'desarrollar'
    ]
    
    tiene_verbo = any(verbo in titulo.lower() for verbo in verbos_accion)
    
    if not tiene_verbo:
        return (True, f"{ValidationEmojis.FORMAT_OK} T√≠tulo aceptable. Sugerencia: inicia con un verbo de acci√≥n.")
    
    return (True, f"{ValidationEmojis.VALID} T√≠tulo descriptivo y claro.")


async def handle_wizard_text_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User]
) -> None:
    """
    Procesa inputs de texto cuando hay un wizard activo.
    
    Args:
        update: Update de Telegram con mensaje de texto
        context: Contexto de la conversaci√≥n con wizard state
    """
    if not update.message or not update.message.text:
        return
    
    # Verificar si hay wizard activo
    wizard = context.user_data.get('wizard')
    if not wizard:
        # No hay wizard activo, dejar que message_handler lo procese
        return
    
    text_input = update.message.text.strip()
    current_step = wizard.get('current_step', 0)
    wizard_data = wizard.get('data', {})
    
    logger.bind(wizard=True).info(
        f"Wizard text input - Step {current_step}: {text_input[:50]}",
        user_id=update.effective_user.id if update.effective_user else None
    )
    
    # Step 2: C√≥digo
    if current_step == 2:
        await _handle_codigo_input(update, context, text_input)
    
    # Step 3: T√≠tulo
    elif current_step == 3:
        await _handle_titulo_input(update, context, text_input)
    
    # Step 4: Delegado ID
    elif current_step == 4:
        await _handle_delegado_input(update, context, text_input)
    
    # Step 5: Asignados (IDs separados por comas)
    elif current_step == 5:
        await _handle_asignados_input(update, context, text_input)
    
    else:
        await update.message.reply_text(
            f"‚ùå Estado de wizard inv√°lido (step {current_step}). "
            f"Usa /start para comenzar de nuevo."
        )


async def _handle_step_2_codigo(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    codigo: str
) -> None:
    """
    Valida y guarda el c√≥digo de la tarea con validaci√≥n en tiempo real.
    
    Args:
        update: Update de Telegram
        context: Contexto con wizard state
        codigo: C√≥digo ingresado por el usuario
    """
    # Validaci√≥n en tiempo real
    es_valido, mensaje = validate_codigo(codigo)
    
    if not es_valido:
        await update.message.reply_text(
            f"{mensaje}\n\n"
            f"Intenta nuevamente con un c√≥digo v√°lido:"
        )
        return
    
    # Guardar en wizard
    context.user_data['wizard']['data']['codigo'] = codigo
    context.user_data['wizard']['current_step'] = 3
    
    logger.bind(wizard=True).info(
        f"Wizard Step 2 completado: c√≥digo={codigo}",
        user_id=update.effective_user.id if update.effective_user else None
    )
    
    # Guardar en wizard
    context.user_data['wizard']['data']['codigo'] = codigo
    context.user_data['wizard']['current_step'] = 3
    
    logger.bind(wizard=True).info(
        f"Wizard Step 2 completado: c√≥digo={codigo}",
        user_id=update.effective_user.id if update.effective_user else None
    )
    
    # Step 3: Solicitar t√≠tulo
    keyboard = KeyboardFactory.back_button("crear:cancel")
    header = get_step_header(3, "Crear Nueva Tarea")
    await update.message.reply_text(
        f"{mensaje}\n\n"  # Mostrar feedback positivo
        f"{header}\n"
        f"C√≥digo: `{codigo}`\n\n"
        f"‚úèÔ∏è *Ingresa el t√≠tulo de la tarea:*\n\n"
        f"üí° *Consejos:* S√© espec√≠fico y claro\n"
        f"üìù *M√°ximo:* 100 caracteres",  # Corregido: 100 caracteres (consistente con validaci√≥n)
        reply_markup=keyboard,
        parse_mode="Markdown"
    )


async def _handle_codigo_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    codigo: str
) -> None:
    """
    Valida y guarda el c√≥digo de la tarea con validaci√≥n en tiempo real.
    
    Args:
        update: Update de Telegram
        context: Contexto con wizard state
        codigo: C√≥digo ingresado por el usuario
    """
    # Validaci√≥n en tiempo real
    es_valido, mensaje = validate_codigo(codigo)
    
    if not es_valido:
        await update.message.reply_text(
            f"{mensaje}\n\n"
            f"Intenta nuevamente con un c√≥digo v√°lido:"
        )
        return
    
    # Guardar en wizard
    context.user_data['wizard']['data']['codigo'] = codigo.upper()
    context.user_data['wizard']['current_step'] = 3
    
    logger.bind(wizard=True).info(
        f"Wizard Step 2 completado: codigo={codigo}",
        user_id=update.effective_user.id if update.effective_user else None
    )
    
    # Step 3: Solicitar t√≠tulo
    await update.message.reply_text(
        f"‚úÖ C√≥digo guardado: *{codigo.upper()}*\n\n"
        f"üè∑Ô∏è *Paso 3/6:* Escribe el t√≠tulo de la tarea\n"
        f"üí° *Gu√≠a:* T√≠tulo descriptivo (5-200 caracteres)\n"
        f"üìù *Ejemplo:* Patrullaje nocturno sector norte",
        parse_mode='Markdown'
    )


async def _handle_titulo_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    titulo: str
) -> None:
    """
    Valida y guarda el t√≠tulo de la tarea con validaci√≥n en tiempo real.
    
    Args:
        update: Update de Telegram
        context: Contexto con wizard state
        titulo: T√≠tulo ingresado por el usuario
    """
    # Validaci√≥n en tiempo real
    es_valido, mensaje = validate_titulo(titulo)
    
    if not es_valido:
        await update.message.reply_text(
            f"{mensaje}\n\n"
            f"Intenta nuevamente con un t√≠tulo descriptivo:"
        )
        return
    
    # Guardar en wizard
    context.user_data['wizard']['data']['titulo'] = titulo
    context.user_data['wizard']['current_step'] = 4
    
    logger.bind(wizard=True).info(
        f"Wizard Step 3 completado: titulo={titulo[:50]}",
        user_id=update.effective_user.id if update.effective_user else None
    )
    
    # Step 4: Solicitar delegado
    # TODO: Llamar a API para obtener lista de delegados
    # Por ahora, solicitar ID manualmente
    keyboard = KeyboardFactory.back_button("crear:cancel")
    await update.message.reply_text(
        f"üìù *Crear Tarea - Paso 4 de 6*\n\n"
        f"T√≠tulo: {titulo}\n\n"
        f"Por favor, env√≠a el *ID del delegado*\n"
        f"(ejemplo: 123):",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )


async def _handle_delegado_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    delegado_input: str
) -> None:
    """
    Valida y guarda el ID del delegado.
    
    Args:
        update: Update de Telegram
        context: Contexto con wizard state
        delegado_input: ID del delegado ingresado
    """
    # Validaci√≥n
    try:
        delegado_id = int(delegado_input)
    except ValueError:
        await update.message.reply_text(
            "‚ùå El ID del delegado debe ser un n√∫mero. Intenta nuevamente:"
        )
        return
    
    # Guardar en wizard
    context.user_data['wizard']['data']['delegado_id'] = delegado_id
    context.user_data['wizard']['current_step'] = 5
    
    logger.bind(wizard=True).info(
        f"Wizard Step 4 completado: delegado_id={delegado_id}",
        user_id=update.effective_user.id if update.effective_user else None
    )
    
    # Step 5: Solicitar asignados
    keyboard = KeyboardFactory.back_button("crear:cancel")
    await update.message.reply_text(
        f"üìù *Crear Tarea - Paso 5 de 6*\n\n"
        f"Delegado: ID {delegado_id}\n\n"
        f"Por favor, env√≠a los *IDs de agentes asignados*\n"
        f"separados por comas (ej: 101,102,103):",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )


async def _handle_asignados_input(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User],
    asignados_input: str
) -> None:
    """
    Valida y guarda los IDs de asignados.
    
    Args:
        update: Update de Telegram
        context: Contexto con wizard state
        asignados_input: IDs separados por comas
    """
    # Validaci√≥n y parsing
    try:
        asignados_ids = [int(x.strip()) for x in asignados_input.split(',')]
    except ValueError:
        await update.message.reply_text(
            "‚ùå Formato inv√°lido. Usa n√∫meros separados por comas (ej: 101,102,103).\n"
            "Intenta nuevamente:"
        )
        return
    
    if not asignados_ids:
        await update.message.reply_text(
            "‚ùå Debes asignar al menos un agente. Intenta nuevamente:"
        )
        return
    
    # Guardar en wizard
    context.user_data['wizard']['data']['asignados'] = asignados_ids
    context.user_data['wizard']['current_step'] = 6
    
    logger.bind(wizard=True).info(
        f"Wizard Step 5 completado: asignados={asignados_ids}",
        user_id=update.effective_user.id if update.effective_user else None
    )
    
    # Step 6: Mostrar resumen
    await _show_wizard_summary(update, context)


async def _show_wizard_summary(
    update: Update,
    context: CallbackContext[Bot, Update, Chat, User]
) -> None:
    """
    Muestra resumen del wizard antes de crear la tarea.
    
    Args:
        update: Update de Telegram
        context: Contexto con datos del wizard
    """
    wizard_data = context.user_data.get('wizard', {}).get('data', {})
    
    tipo = wizard_data.get('tipo', 'N/A')
    codigo = wizard_data.get('codigo', 'N/A')
    titulo = wizard_data.get('titulo', 'N/A')
    delegado_id = wizard_data.get('delegado_id', 'N/A')
    asignados = wizard_data.get('asignados', [])
    
    summary_text = (
        f"üìã *Resumen de la Tarea - Paso 6 de 6*\n\n"
        f"*C√≥digo:* `{codigo}`\n"
        f"*T√≠tulo:* {titulo}\n"
        f"*Tipo:* {tipo}\n"
        f"*Delegado:* ID {delegado_id}\n"
        f"*Asignados:* {', '.join(map(str, asignados)) if asignados else 'Ninguno'}\n\n"
        f"¬øConfirmar creaci√≥n?"
    )
    
    keyboard = KeyboardFactory.confirmation("crear:confirm", "crear:cancel")
    
    await update.message.reply_text(
        summary_text,
        reply_markup=keyboard,
        parse_mode="Markdown"
    )


# Definir handler con filtro
# Solo procesa si hay wizard activo (se verifica dentro de la funci√≥n)
wizard_text_handler = MessageHandler(
    filters.TEXT & ~filters.COMMAND,
    handle_wizard_text_input
)
